let arr = [5, 6, 8, 1, 4, 7, 3, 2];
//bubbleSort
function bubbleSort( arr ) {
    //Եթե զանգվածի երկարությունը փոքր է 2-ից, վերադարձնում ենք զանգվածը։
    if ( arr.length === 1 ) return arr;
    let i, j, length = arr.length;
    //Հակառակ դեպքում զանգվածի երկարությամբ ցիկլով պտտվում ենք՝ համեմատելով յուրաքանչյուր
    //ինդեքսի արժեքն իրեն հաջորդող ինդեքսի արժեքի հետ։
    for (i = 0; i < length-1; i++) {
        for (j = 0; j < length-i-1; j++) {
            //Յուրաանչյուր ցիկլի ժամանակ համեմատում է այդ ցիկլում դիտարկվող էլեմենտի և նրան
            //հաջորդող էլեմենտի արժեքները։
            if ( arr[j] > arr[j+1] ) {
                //Եթե հաջորդող արժեքն ավելի մեծ է, արժեքները տեղերով փոխում ենք։
                //Առաջին էլեմենտին վերագրում ենք իր և երկրորդ էլեմենտի գումարը (ժամանակավոր 
                //պահելու համար)
                arr[j] += arr[j + 1];
                //Երկրորդ ինդեքսին վերագրում ենք պահված արժեքից հանած իր արժեքը։
                //Այսպիսով ներկայիս ինդեքսի էլեմենտի արժեքը վերագրեցինք 1 ինդեքսով մեծ
                //էլեմենտին։
                arr[j + 1] = arr[j] - arr[j + 1];
                //Ներկայիս ինդեքսին վերագրում ենք իր արժեքից հանած 1-ով մեծ ինդեքսի արժեքը,
                //որի արժեքն արդեն իր նախկին արժեքն է։
                arr[j] = arr[j] - arr[j + 1];
            }
        }
    }//Վերադարձնում ենք սորտավորված զանգվածը։
return arr;
}//Ալգորիթմի բարդությունը (complexity) ֊ O(n²) է:
console.log( bubbleSort(arr) );

//quickSort
function quickSort(arr) {
    //Եթե զանգվածի երկարությունը փոքր է 2-ից, վերադարձնում ենք զանգվածը։
    if (arr.length < 2) return arr;
    //Ստեղծում ենք փոփոխական, որին վերագրում ենք զանգվածի առաջին արժեքը՝ պայմանականորեն
    //2 զանգված ստեղծելու համար, որոնցից մեկը փոքր կլինի զանգվածի առաջին արժեքից, երկրորդը՝
    //մեծ։
    let pivot = arr[0];
    const left = [];
    const right = [];
    //Հակառակ դեպքում զանգվածի երկարությամբ ցիկլով պտտվում ենք՝ համեմատելով յուրաքանչյուր
    //ինդեքսի արժեքը զանգվածի առաջին էլեմենտի արժեքի հետ։
    for (let i = 1; i < arr.length; i++) {
        //Եթե տվյալ ինդեքսի էլեմենտի արժեքը մեծ է զանգվածի առաջին էլեմենտի արժեքից
        //ապա այն ավելացնում ենք left զանգվածին, հակառակ դեպքում՝ right զանգվածին։
      if (pivot > arr[i]) {
        left.push(arr[i]);
      } else {
        right.push(arr[i]);
      }
    }//Ռեկուրսիայի միջոցով նույն ֆունցիան կանչում ենք left և right զանգվածների համար 
    //մինչև զանգվածի երկարությունը լինի 1։
    //Յուրաքանչյուր անգամ concat-ի միջոցով կպցվում են left զանգվածը, զանգվածի առաջին 
    //ինդեքսի արժեքը և right զանգվածը։
    return quickSort(left).concat(pivot, quickSort(right));
    //Վերջում վերադարձվում է սորտավորված զանգվածը։
  }//Ալգորիթմի բարդությունը (complexity) ֊ O(nlogn)  է:
console.log(quickSort(arr));